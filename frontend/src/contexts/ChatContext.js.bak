import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import io from 'socket.io-client';
import { useAuth } from './AuthContext';

const ChatContext = createContext();

export const useChat = () => {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
};

export const ChatProvider = ({ children }) => {
  const { user } = useAuth();
  const [socket, setSocket] = useState(null);
  const [conversations, setConversations] = useState([]);
  const [groups, setGroups] = useState(() => []);  // Initialize with empty array
  const [currentConversation, setCurrentConversation] = useState(null);
  const [currentGroup, setCurrentGroup] = useState(null);
  const [messagesByConversation, setMessagesByConversation] = useState({});
  const [messagesByGroup, setMessagesByGroup] = useState({});
  const [loading, setLoading] = useState(false);
  const [users, setUsers] = useState([]);

  // Initialize socket connection
  useEffect(() => {
    if (user) {
      const newSocket = io('http://localhost:5000', {
        auth: {
          token: localStorage.getItem('token')
        }
      });

      newSocket.on('connect', () => {
        console.log('Socket connected');
        newSocket.emit('join_user_room', user.id);
      });

      // Handle new direct messages
      newSocket.on('new_message', (message) => {
        console.log('📨 New direct message received:', message);
        
        const otherUserId = message.sender_id === user.id ? message.recipient_id : message.sender_id;
        
        // Add message to conversation storage
        setMessagesByConversation(prev => ({
          ...prev,
          [otherUserId]: [...(prev[otherUserId] || []), message]
        }));
      });

      // Handle new group messages
      newSocket.on('new_group_message', (message) => {
        console.log('👥 New group message received:', message);
        
        // Add message to group storage
        setMessagesByGroup(prev => ({
          ...prev,
          [message.group_id]: [...(prev[message.group_id] || []), message]
        }));
        
        // Update conversations list
        if (message.recipient_id === user.id) {
          console.log('📋 Received new message, updating conversation list...');
          
          setConversations(prev => {
            const existingConversation = prev.find(conv => conv.other_user_id === message.sender_id);
            
            if (!existingConversation) {
              console.log('➕ Adding new conversation to list for user:', message.sender_id);
              const newConversation = {
                other_user_id: message.sender_id,
                other_user_first_name: message.sender_first_name,
                other_user_last_name: message.sender_last_name,
                other_user_email: message.sender_email,
                other_user_role: 'member',
                last_message: message.message_text,
                last_message_time: message.created_at,
                last_sender_id: message.sender_id
              };
              
              return [newConversation, ...prev];
            } else {
              // Update existing conversation
              return prev.map(conv => 
                conv.other_user_id === message.sender_id
                  ? {
                      ...conv,
                      last_message: message.message_text,
                      last_message_time: message.created_at,
                      last_sender_id: message.sender_id
                    }
                  : conv
              ).sort((a, b) => new Date(b.last_message_time) - new Date(a.last_message_time));
            }
          });
        }
      });

      newSocket.on('message_sent', (message) => {
        console.log('📤 Message sent confirmation:', message);
        
        const otherUserId = message.sender_id === user.id ? message.recipient_id : message.sender_id;
        
        // Add sent message to conversation storage
        setMessagesByConversation(prev => ({
          ...prev,
          [otherUserId]: [...(prev[otherUserId] || []), message]
        }));
        
        // Update conversations for sent messages
        setConversations(prev => {
          const existingConversation = prev.find(conv => conv.other_user_id === otherUserId);
          
          if (!existingConversation) {
            console.log('➕ Adding new conversation for sent message to user:', otherUserId);
            const newConversation = {
              other_user_id: otherUserId,
              other_user_first_name: message.recipient_first_name || 'User',
              other_user_last_name: message.recipient_last_name || '',
              other_user_email: message.recipient_email || '',
              other_user_role: 'member',
              last_message: message.message_text,
              last_message_time: message.created_at,
              last_sender_id: message.sender_id
            };
            
            return [newConversation, ...prev];
          } else {
            // Update existing conversation
            return prev.map(conv => 
              conv.other_user_id === otherUserId
                ? {
                    ...conv,
                    last_message: message.message_text,
                    last_message_time: message.created_at,
                    last_sender_id: message.sender_id
                  }
                : conv
            ).sort((a, b) => new Date(b.last_message_time) - new Date(a.last_message_time));
          }
        });
      });

      setSocket(newSocket);

      return () => {
        newSocket.close();
      };
    }
  }, [user]);

  // Fetch groups
  const fetchGroups = useCallback(async () => {
    if (!user) return;
    
    try {
      console.log('🔄 Fetching groups...');
      const response = await axios.get('http://localhost:5000/api/chat-groups', {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      
      console.log('👥 Groups fetched:', response.data.groups.length);
      
      // Sort groups by last message time
      const sortedGroups = response.data.groups.sort(
        (a, b) => new Date(b.last_message_time || b.created_at) - new Date(a.last_message_time || a.created_at)
      );
      
      setGroups(sortedGroups);
    } catch (error) {
      console.error('Failed to fetch groups:', error);
    }
  }, [user]);

  // Fetch conversations
  const fetchConversations = useCallback(async () => {
    if (!user) return;
    
    try {
      console.log('🔄 Fetching conversations...');
      const response = await axios.get('http://localhost:5000/api/chat/conversations', {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      
      console.log('📋 Conversations fetched:', response.data.conversations.length);
      
      // Sort conversations by last message time
      const sortedConversations = response.data.conversations.sort(
        (a, b) => new Date(b.last_message_time) - new Date(a.last_message_time)
      );
      
      setConversations(sortedConversations);
    } catch (error) {
      console.error('Failed to fetch conversations:', error);
    }
  }, [user]);

  // Fetch users for new conversations
  const fetchUsers = useCallback(async () => {
    if (!user) return;
    
    try {
      const response = await axios.get('http://localhost:5000/api/chat/users', {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      setUsers(response.data.users);
    } catch (error) {
      console.error('Failed to fetch users:', error);
    }
  }, [user]);

  // Send message to a group
  const sendGroupMessage = async (groupId, messageText) => {
    try {
      console.log('📨 Sending group message to:', groupId);
      const response = await axios.post(`http://localhost:5000/api/chat-groups/${groupId}/send`, {
        message_text: messageText,
        message_type: 'text'
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      const newMessage = response.data.message;

      // Update messages in state
      setMessagesByGroup(prev => ({
        ...prev,
        [groupId]: [...(prev[groupId] || []), newMessage]
      }));

      // Emit message through socket
      socket?.emit('send_group_message', {
        ...newMessage,
        group_id: groupId,
        sender_first_name: user.first_name,
        sender_last_name: user.last_name,
        sender_email: user.email,
        sender_role: user.role
      });

      // Update group in the list
      setGroups(prev => 
        prev.map(group => 
          group.id === groupId
            ? {
                ...group,
                last_message: messageText,
                last_message_time: new Date().toISOString(),
                last_sender_id: user.id,
                last_sender_name: `${user.first_name} ${user.last_name}`
              }
            : group
        ).sort((a, b) => new Date(b.last_message_time || b.created_at) - new Date(a.last_message_time || a.created_at))
      );

      return newMessage;
    } catch (error) {
      console.error('Failed to send group message:', error);
      throw error;
    }
  };

  // Create a new group
  const createGroup = async (name, description = '', members = []) => {
    try {
      console.log('👥 Creating new group:', name);
      const response = await axios.post('http://localhost:5000/api/chat-groups', {
        name,
        description,
        members
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      console.log('✅ Group created successfully:', response.data);
      
      // Add the new group to the list
      const newGroup = response.data.group;
      setGroups(prev => [newGroup, ...prev]);
      
      return newGroup;
    } catch (error) {
      console.error('Failed to create group:', error);
      throw error;
    }
  };

  // Open a group chat
  const openGroup = async (groupId) => {
    try {
      setLoading(true);
      console.log('👥 Opening group:', groupId);

      const group = groups.find(g => g.id === groupId);
      if (group) {
        setCurrentGroup(group);
        setCurrentConversation(null); // Close any open direct conversation

        // Join the group's socket room
        socket?.emit('join_group', groupId);

        // Get group messages if not already loaded
        if (!messagesByGroup[groupId]) {
          console.log('📡 Fetching group messages...');
          const response = await axios.get(`http://localhost:5000/api/chat-groups/${groupId}/messages`, {
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('token')}`
            }
          });

          setMessagesByGroup(prev => ({
            ...prev,
            [groupId]: response.data.messages
          }));
        } else {
          console.log('📚 Using cached group messages');
        }
      }
    } catch (error) {
      console.error('Failed to open group:', error);
    } finally {
      setLoading(false);
    }
  };

  // Open conversation - WhatsApp-like behavior
  const openConversation = async (userId, userData = null) => {
    try {
      setLoading(true);
      console.log('💬 Opening conversation with user:', userId);

      let conversationData = userData;

      // If no user data provided, try to get it from conversations list
      if (!conversationData) {
        const existingConv = conversations.find(conv => conv.other_user_id === userId);
        if (existingConv) {
          conversationData = existingConv;
        } else {
          // Fetch user data if not available
          try {
            const userResponse = await axios.get(`http://localhost:5000/api/chat/users`, {
              headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`
              }
            });

            const userData = userResponse.data.users.find(u => u.id === parseInt(userId));
            if (userData) {
              conversationData = {
                other_user_id: userId,
                other_user_first_name: userData.first_name,
                other_user_last_name: userData.last_name,
                other_user_email: userData.email,
                other_user_role: userData.role
              };
            } else {
              conversationData = {
                other_user_id: userId,
                other_user_first_name: 'Loading...',
                other_user_last_name: '',
                other_user_email: '',
                other_user_role: 'member'
              };
            }
          } catch (error) {
            console.error('Failed to fetch user data:', error);
            conversationData = {
              other_user_id: userId,
              other_user_first_name: 'User',
              other_user_last_name: '',
              other_user_email: '',
              other_user_role: 'member'
            };
          }
        }
      }

      setCurrentConversation(conversationData);

      // Check if we already have messages for this conversation
      if (messagesByConversation[userId] && messagesByConversation[userId].length > 0) {
        console.log('📚 Using cached messages for user:', userId);
      } else {
        console.log('📡 Fetching messages from server for user:', userId);
        const response = await axios.get(`http://localhost:5000/api/chat/conversation/${userId}`, {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        });

        setMessagesByConversation(prev => ({
          ...prev,
          [userId]: response.data.messages
        }));
      }

      // Mark messages as read
      await axios.put(`http://localhost:5000/api/chat/mark-read/${userId}`, {}, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

    } catch (error) {
      console.error('Failed to open conversation:', error);
    } finally {
      setLoading(false);
    }
  };

  // Send message - WhatsApp-like behavior
  const sendMessage = async (recipientId, messageText) => {
    try {
      const response = await axios.post('http://localhost:5000/api/chat/send', {
        recipient_id: recipientId,
        message_text: messageText
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      const newMessage = response.data.message;
      
      // Add message to conversation storage
      setMessagesByConversation(prev => ({
        ...prev,
        [recipientId]: [...(prev[recipientId] || []), newMessage]
      }));

      // WHATSAPP-LIKE BEHAVIOR: Immediately add conversation to left sidebar
      setConversations(prev => {
        const existingConversation = prev.find(conv => conv.other_user_id === recipientId);
        
        if (!existingConversation) {
          console.log('➕ Adding new conversation to sidebar for sent message to user:', recipientId);
          
          // Find the recipient user data
          const recipientUser = users.find(u => u.id === parseInt(recipientId));
          
          const newConversation = {
            other_user_id: recipientId,
            other_user_first_name: recipientUser?.first_name || 'User',
            other_user_last_name: recipientUser?.last_name || '',
            other_user_email: recipientUser?.email || '',
            other_user_role: recipientUser?.role || 'member',
            last_message: messageText,
            last_message_time: newMessage.created_at,
            last_sender_id: user.id
          };
          
          return [newConversation, ...prev];
        } else {
          // Update existing conversation
          return prev.map(conv => 
            conv.other_user_id === recipientId
              ? {
                  ...conv,
                  last_message: messageText,
                  last_message_time: newMessage.created_at,
                  last_sender_id: user.id
                }
              : conv
          ).sort((a, b) => new Date(b.last_message_time) - new Date(a.last_message_time));
        }
      });

      return newMessage;
    } catch (error) {
      console.error('Failed to send message:', error);
      throw error;
    }
  };

  // Send file message - WhatsApp-like behavior
  const sendFileMessage = async (recipientId, file, messageText = '') => {
    try {
      const formData = new FormData();
      formData.append('recipient_id', recipientId);
      formData.append('message_text', messageText);
      formData.append('file', file);

      const response = await axios.post('http://localhost:5000/api/chat/send-file', formData, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
          'Content-Type': 'multipart/form-data'
        }
      });

      const newMessage = response.data.message;
      
      // Add message to conversation storage
      setMessagesByConversation(prev => ({
        ...prev,
        [recipientId]: [...(prev[recipientId] || []), newMessage]
      }));

      // WHATSAPP-LIKE BEHAVIOR: Immediately add conversation to left sidebar
      setConversations(prev => {
        const existingConversation = prev.find(conv => conv.other_user_id === recipientId);
        
        if (!existingConversation) {
          console.log('➕ Adding new conversation to sidebar for sent file to user:', recipientId);
          
          // Find the recipient user data
          const recipientUser = users.find(u => u.id === parseInt(recipientId));
          
          const newConversation = {
            other_user_id: recipientId,
            other_user_first_name: recipientUser?.first_name || 'User',
            other_user_last_name: recipientUser?.last_name || '',
            other_user_email: recipientUser?.email || '',
            other_user_role: recipientUser?.role || 'member',
            last_message: messageText || `📎 ${file.name}`,
            last_message_time: newMessage.created_at,
            last_sender_id: user.id
          };
          
          return [newConversation, ...prev];
        } else {
          // Update existing conversation
          return prev.map(conv => 
            conv.other_user_id === recipientId
              ? {
                  ...conv,
                  last_message: messageText || `📎 ${file.name}`,
                  last_message_time: newMessage.created_at,
                  last_sender_id: user.id
                }
              : conv
          ).sort((a, b) => new Date(b.last_message_time) - new Date(a.last_message_time));
        }
      });

      return newMessage;
    } catch (error) {
      console.error('Failed to send file message:', error);
      throw error;
    }
  };

  // Close conversation without clearing messages
  const closeConversation = () => {
    console.log('❌ Closing conversation (messages preserved)');
    setCurrentConversation(null);
  };

  // Open a group chat
  const openGroup = async (groupId) => {
    try {
      setLoading(true);
      console.log('👥 Opening group:', groupId);

      // Find the group in the list or fetch it
      const group = groups.find(g => g.id === groupId);
      if (group) {
        setCurrentGroup(group);
      }

      // Join the group's socket room
      socket?.emit('join_group', groupId);

      // Get group messages if not already loaded
      if (!messagesByGroup[groupId]) {
        const response = await axios.get(`http://localhost:5000/api/chat-groups/${groupId}/messages`, {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        });

        setMessagesByGroup(prev => ({
          ...prev,
          [groupId]: response.data.messages
        }));
      }
    } catch (error) {
      console.error('Failed to open group:', error);
    } finally {
      setLoading(false);
    }
  };

  // Get current messages (either direct or group)
  const getCurrentMessages = () => {
    if (currentConversation) {
      return messagesByConversation[currentConversation.other_user_id] || [];
    }
    if (currentGroup) {
      return messagesByGroup[currentGroup.id] || [];
    }
    return [];
  };

  // Load initial data
  useEffect(() => {
    if (user) {
      fetchConversations();
      fetchUsers();
      fetchGroups();
    }
  }, [user, fetchConversations, fetchUsers, fetchGroups]);

  // Create a new group
  const createGroup = async (name, description = '', members = []) => {
    try {
      console.log('👥 Creating new group:', name);
      const response = await axios.post('http://localhost:5000/api/chat-groups', {
        name,
        description,
        members
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      console.log('✅ Group created successfully:', response.data);
      
      // Refresh groups list
      await fetchGroups();
      
      return response.data.group;
    } catch (error) {
      console.error('Failed to create group:', error);
      throw error;
    }
  };

  // Send message to a group
  const sendGroupMessage = async (groupId, messageText) => {
    try {
      console.log('📨 Sending group message to:', groupId);
      const response = await axios.post(`http://localhost:5000/api/chat-groups/${groupId}/send`, {
        message_text: messageText,
        message_type: 'text'
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      const newMessage = response.data.message;

      // Update messages in state
      setMessagesByGroup(prev => ({
        ...prev,
        [groupId]: [...(prev[groupId] || []), newMessage]
      }));

      // Emit message through socket
      socket?.emit('send_group_message', {
        ...newMessage,
        group_id: groupId,
        sender_first_name: user.first_name,
        sender_last_name: user.last_name,
        sender_email: user.email,
        sender_role: user.role
      });

      // Update group in the list
      setGroups(prev => 
        prev.map(group => 
          group.id === groupId
            ? {
                ...group,
                last_message: messageText,
                last_message_time: new Date().toISOString(),
                last_sender_id: user.id,
                last_sender_name: `${user.first_name} ${user.last_name}`
              }
            : group
        ).sort((a, b) => new Date(b.last_message_time || b.created_at) - new Date(a.last_message_time || a.created_at))
      );

      return newMessage;
    } catch (error) {
      console.error('Failed to send group message:', error);
      throw error;
    }
  };

  // Create a new group
  const createGroup = async (name, description = '', members = []) => {
    try {
      console.log('👥 Creating new group:', name);
      const response = await axios.post('http://localhost:5000/api/chat-groups', {
        name,
        description,
        members
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });

      console.log('✅ Group created successfully:', response.data);
      
      // Add the new group to the list
      const newGroup = response.data.group;
      setGroups(prev => [newGroup, ...prev]);
      
      return newGroup;
    } catch (error) {
      console.error('Failed to create group:', error);
      throw error;
    }
  };

  const value = {
    socket,
    conversations,
    groups,
    currentConversation,
    currentGroup,
    messages: getCurrentMessages(),
    loading,
    users,
    openConversation,
    openGroup,
    sendMessage,
    sendGroupMessage,
    sendFileMessage,
    closeConversation,
    createGroup,
    fetchGroups
  };

  return (
    <ChatContext.Provider value={value}>
      {children}
    </ChatContext.Provider>
  );
};